<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yiwenshao.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="之前已经介绍了SQL语句经过mysql-proxy的lua脚本与C++库交互的过程。在CryptDB的处理中，总体分为两个阶段：rewrite与next。本文介绍在rewrite和next这两个阶段中比较重要的两个类层次：handler以及executor。">
<meta property="og:type" content="article">
<meta property="og:title" content="CryptDB代码分析2-handler与executor">
<meta property="og:url" content="https://yiwenshao.github.io/2018/03/06/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902-handler%E4%B8%8Eexecutor/index.html">
<meta property="og:site_name" content="yiwenshao">
<meta property="og:description" content="之前已经介绍了SQL语句经过mysql-proxy的lua脚本与C++库交互的过程。在CryptDB的处理中，总体分为两个阶段：rewrite与next。本文介绍在rewrite和next这两个阶段中比较重要的两个类层次：handler以及executor。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yiwenshao.github.io/blogGraph/project/cryptdb/classSQLHandler.png">
<meta property="og:image" content="https://yiwenshao.github.io/blogGraph/project/cryptdb/classAlterSubHandler.png">
<meta property="og:image" content="https://yiwenshao.github.io/blogGraph/project/cryptdb/classAbstractQueryExecutor.png">
<meta property="article:published_time" content="2018-03-05T16:19:14.000Z">
<meta property="article:modified_time" content="2018-03-05T16:19:14.000Z">
<meta property="article:author" content="Yiwen Shao">
<meta property="article:tag" content="CryptDB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yiwenshao.github.io/blogGraph/project/cryptdb/classSQLHandler.png">


<link rel="canonical" href="https://yiwenshao.github.io/2018/03/06/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902-handler%E4%B8%8Eexecutor/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yiwenshao.github.io/2018/03/06/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902-handler%E4%B8%8Eexecutor/","path":"2018/03/06/CryptDB代码分析2-handler与executor/","title":"CryptDB代码分析2-handler与executor"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CryptDB代码分析2-handler与executor | yiwenshao</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">yiwenshao</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E6%94%B9%E5%86%99%E6%96%B9%E5%BC%8F%E4%B8%8Equery%E6%81%A2%E5%A4%8D%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">SQL改写方式与query恢复介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%86%E7%B1%BB%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">SQL解析与分类处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%B1%BBhandler"><span class="nav-number">3.</span> <span class="nav-text">三类handler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dml-handler%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">dml handler：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ddl-handler%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">ddl handler：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Alter-table-handler"><span class="nav-number">3.3.</span> <span class="nav-text">Alter table handler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Ehandler%E5%88%B0executor"><span class="nav-number">4.</span> <span class="nav-text">从handler到executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">5.</span> <span class="nav-text">一个非常简单的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%96%87%E7%8C%AE"><span class="nav-number">7.</span> <span class="nav-text">相关文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yiwen Shao"
      src="https://yiwenshao.github.io/blogGraph//avatar/zoro.jpg">
  <p class="site-author-name" itemprop="name">Yiwen Shao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwenshao.github.io/2018/03/06/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902-handler%E4%B8%8Eexecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://yiwenshao.github.io/blogGraph//avatar/zoro.jpg">
      <meta itemprop="name" content="Yiwen Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yiwenshao">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CryptDB代码分析2-handler与executor
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-06 00:19:14" itemprop="dateCreated datePublished" datetime="2018-03-06T00:19:14+08:00">2018-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Cryptdb%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">Cryptdb的设计与实现</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>之前已经介绍了SQL语句经过mysql-proxy的lua脚本与C++库交互的过程。在CryptDB的处理中，总体分为两个阶段：rewrite与next。本文介绍在rewrite和next这两个阶段中比较重要的两个类层次：handler以及executor。</p>
<span id="more"></span>

<h3 id="SQL改写方式与query恢复介绍"><a href="#SQL改写方式与query恢复介绍" class="headerlink" title="SQL改写方式与query恢复介绍"></a>SQL改写方式与query恢复介绍</h3><p>首先考虑如何对SQL语句进行加密。CryptDB不直接处理字符串，而是借用了MySQL5.5版本的parser先对原始SQL语句进行解析，解析完以后获得一个LEX类型结构，是一个MySQL定义的类。 在加密阶段，对LEX内部的各个成员进行加密，并获得一个加密的LEX结构。 在恢复阶段，则需要将这个加密的LEX结构恢复成字符串类型，从而获得加密的SQL语句。</p>
<p>举例来说，对于一个SQL语句<strong>SELECT id from student</strong>， id 需要被加密。而这个语句解析成LEX 结构以后，id是在item_list成员里面，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lex-&gt;select_lex.item_list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对这个item_list遍历，可以得到每个被选择的列对应的结构，是一个<strong>Item_field</strong>类型。其内部就包含了filed的名字，也就是id。加密过程，就是把这个内部的成员修改成自己想要的加密列的名字。完成LEX结构的加密以后，需要从LEX结构恢复成string类型的SQL语句，相关代码位于<strong>parser/stringify.hh</strong>。比如针对上面的SELECT语句，已经得到了加密以后的LEX结构，要重新得到字符串类型的SQL语句，可以通过如下的代码进行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//代码来源 parser/stringfy.hh</span><br><span class="line">//参数lex是加密以后的lex</span><br><span class="line">static inline std::ostream&amp;</span><br><span class="line">operator&lt;&lt;(std::ostream &amp;out, LEX &amp;lex)&#123;</span><br><span class="line">    String s;</span><br><span class="line">    switch (lex.sql_command) &#123;</span><br><span class="line">    //对于select语句，直接调用一次函数就可以恢复SQL语句</span><br><span class="line">    case SQLCOM_SELECT:</span><br><span class="line">    	//string类型的结果保存在ostream类型的变量out里面</span><br><span class="line">        out &lt;&lt; lex.unit;</span><br><span class="line">        break;</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该函数完成lex.unit到字符串的转化。</span><br><span class="line">static inline std::ostream&amp;</span><br><span class="line">operator&lt;&lt;(std::ostream &amp;out, SELECT_LEX_UNIT &amp;select_lex_unit)&#123;</span><br><span class="line">    String s;</span><br><span class="line">    select_lex_unit.print(&amp;s, QT_ORDINARY);</span><br><span class="line">    return out &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以， 加密过程其实就是SQL语句的解析，以及解析以后的类的成员的修改。要理解完整的SQL解析，加密，以及LEX结构恢复成字符串的代码流程，就需要了解MySQL的parser的内部类的含义，这些在后续的文章中会逐步介绍。</p>
<h3 id="SQL解析与分类处理"><a href="#SQL解析与分类处理" class="headerlink" title="SQL解析与分类处理"></a>SQL解析与分类处理</h3><p>在mysqlproxy/ConnectWrapper.cc的rewrite函数中完成了基本的SQL加密操作。其内部执行SQL加密的入口是：<strong>Rewriter::rewrite</strong>函数。该函数的作用是获得一个QueryRewrite类，这个类包含了改写以后的SQL语句，以及数据解密所需要的元信息。其部分代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QueryRewrite</span><br><span class="line">Rewriter::rewrite(const std::string &amp;q, const SchemaInfo &amp;schema,</span><br><span class="line">                  const std::string &amp;default_db, const ProxyState &amp;ps) &#123;</span><br><span class="line">     //辅助信息</span><br><span class="line">    Analysis analysis(default_db, schema, ps.getMasterKey(),</span><br><span class="line">                      ps.defaultSecurityRating());</span><br><span class="line">    //SQL解析，加密，获得executor类型，在next阶段使用</span><br><span class="line">    AbstractQueryExecutor *const executor =</span><br><span class="line">        Rewriter::dispatchOnLex(analysis, q);</span><br><span class="line">    if (!executor) &#123;</span><br><span class="line">        return QueryRewrite(true, analysis.rmeta, analysis.kill_zone,</span><br><span class="line">                            new NoOpExecutor());</span><br><span class="line">    &#125;</span><br><span class="line">    //QueryRewrite类包含所有必要信息</span><br><span class="line">    return QueryRewrite(true, analysis.rmeta, analysis.kill_zone, executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是调用<strong>Rewriter::dispatchOnLex</strong>函数， 获得executor， 然后返回QueryRewrite类。其中executor中就保存了加密以后的SQL语句。在dispatchOnLex函数中，首先调用MySQL的parer对原始的SQL语句进行解析，获得LEX结构， 然后根据lex.sql_command把SQL语句分为三类：noRewrite，ddl以及dml。不同类型的sql语句分配不同的handler类型进行处理，并返回executor类型，具体如下：</p>
<ul>
<li>对于noRewrite类型, 直接返回SimpleExecutor类型，其作用是直接返回明文的SQL语句，不进行任何的SQL改写操作。</li>
<li>对于DML以及DDL，则分别由不同的handler类型对SQL语句进行处理，并且返回对应的executor结构。</li>
</ul>
<p>其简化的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AbstractQueryExecutor *</span><br><span class="line">Rewriter::dispatchOnLex(Analysis &amp;a, const std::string &amp;query) &#123;</span><br><span class="line">	//使用MySQL的parser进行SQL解析，获得LEX类型</span><br><span class="line">	LEX *const lex = query_parse(query);</span><br><span class="line">	//三种不同的处理</span><br><span class="line">	if(noRewrite(*lex))&#123;</span><br><span class="line">		return new SimpleExecutor();</span><br><span class="line">	&#125;else if(dml_dispatcher-&gt;canDo(lex))&#123;</span><br><span class="line">		const SQLHandler &amp;handler = dml_dispatcher-&gt;dispatch(lex);</span><br><span class="line">		AbstractQueryExecutor executor = handler.transformLex(lex);</span><br><span class="line">		return executor;</span><br><span class="line">	&#125;else if(ddl_dispatcher-&gt;canDo(lex))&#123;</span><br><span class="line">		const SQLHandler &amp;handler = ddl_dispatcher-&gt;dispatch(lex);</span><br><span class="line">		AbstractQueryExecutor executor = handler.transformLex(lex);</span><br><span class="line">		return executor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里的加密处理涉及到dispatcher，handler，以及execotor。Dispatcher根据lex的结构，为SQL语句分配handler，不同类型的SQL语句有不同的handler，用来处理sql语句的加密。加密以后的结果则放置在executor中。dispatcher分配handler是基于map的查找来做的，其map初始化的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">SQLDispatcher *buildDMLDispatcher()&#123;</span><br><span class="line">    DMLHandler *h;</span><br><span class="line">    SQLDispatcher *const dispatcher = new SQLDispatcher();</span><br><span class="line">    h = new InsertHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_INSERT, h);</span><br><span class="line">    h = new InsertHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_REPLACE, h);</span><br><span class="line">    h = new UpdateHandler;</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_UPDATE, h);</span><br><span class="line">    h = new DeleteHandler;</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_DELETE, h);</span><br><span class="line">    h = new MultiDeleteHandler;</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_DELETE_MULTI, h);</span><br><span class="line">    h = new SelectHandler;</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_SELECT, h);</span><br><span class="line">    h = new SetHandler;</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_SET_OPTION, h);</span><br><span class="line">    h = new ShowTablesHandlers;</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_SHOW_TABLES, h);</span><br><span class="line">    h = new ShowCreateTableHandler;</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_SHOW_CREATE,h);</span><br><span class="line">    return dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SQLDispatcher *buildDDLDispatcher()&#123;</span><br><span class="line">    DDLHandler *h;</span><br><span class="line">    SQLDispatcher *dispatcher = new SQLDispatcher();</span><br><span class="line">    h = new CreateTableHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_CREATE_TABLE, h);</span><br><span class="line">    h = new AlterTableHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_ALTER_TABLE, h);</span><br><span class="line">    h = new DropTableHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_DROP_TABLE, h);</span><br><span class="line">    h = new CreateDBHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_CREATE_DB, h);</span><br><span class="line">    h = new ChangeDBHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_CHANGE_DB, h);</span><br><span class="line">    h = new DropDBHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_DROP_DB, h);</span><br><span class="line">    h = new LockTablesHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_LOCK_TABLES, h);</span><br><span class="line">    h = new CreateIndexHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(SQLCOM_CREATE_INDEX, h);</span><br><span class="line">    return dispatcher;</span><br><span class="line">&#125;</span><br><span class="line">//初始化两个全局的dispatcher，内部通过map来保存handler结构</span><br><span class="line">const std::unique_ptr&lt;SQLDispatcher&gt; Rewriter::dml_dispatcher =</span><br><span class="line">    std::unique_ptr&lt;SQLDispatcher&gt;(buildDMLDispatcher());</span><br><span class="line">const std::unique_ptr&lt;SQLDispatcher&gt; Rewriter::ddl_dispatcher =</span><br><span class="line">    std::unique_ptr&lt;SQLDispatcher&gt;(buildDDLDispatcher());</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在实际的代码中，上面的handler处理过程里还包含通过异常处理来调整洋葱层次的代码，这里暂时不做介绍。下面主要关注hander类以及executor类的组织方式以及特点。</p>
<h3 id="三类handler"><a href="#三类handler" class="headerlink" title="三类handler"></a>三类handler</h3><p>我们已经知道了通过不同的handler类，可以处理SQL语句，完成加密的操作。这里，首先给出Handler类的层次结构。</p>
<p><img src="https://yiwenshao.github.io/blogGraph/project/cryptdb/classSQLHandler.png"></p>
<p>此外，对于ALTER TABLE语句，还有额外的subhandler：</p>
<p><img src="https://yiwenshao.github.io/blogGraph/project/cryptdb/classAlterSubHandler.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AlterDispatcher *buildAlterSubDispatcher() &#123;</span><br><span class="line">    AlterDispatcher *dispatcher = new AlterDispatcher();</span><br><span class="line">    AlterSubHandler *h;</span><br><span class="line"></span><br><span class="line">    h = new AddColumnSubHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(ALTER_ADD_COLUMN, h);</span><br><span class="line"></span><br><span class="line">    h = new DropColumnSubHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(ALTER_DROP_COLUMN, h);</span><br><span class="line"></span><br><span class="line">    h = new ChangeColumnSubHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(ALTER_CHANGE_COLUMN, h);</span><br><span class="line"></span><br><span class="line">    h = new ForeignKeySubHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(ALTER_FOREIGN_KEY, h);</span><br><span class="line"></span><br><span class="line">    h = new AddIndexSubHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(ALTER_ADD_INDEX, h);</span><br><span class="line"></span><br><span class="line">    h = new DropIndexSubHandler();</span><br><span class="line">    dispatcher-&gt;addHandler(ALTER_DROP_INDEX, h);</span><br><span class="line"></span><br><span class="line">    h = new DisableOrEnableKeys();</span><br><span class="line">    dispatcher-&gt;addHandler(ALTER_KEYS_ONOFF, h);</span><br><span class="line"></span><br><span class="line">    return dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以看到，不同类型的语句，有不同的handler来处理。这是因为，不同语句的处理流程是不一样的，我们分别来看如下三种handler的特点。</p>
<h4 id="dml-handler："><a href="#dml-handler：" class="headerlink" title="dml handler："></a><strong>dml handler：</strong></h4><p>dml系列的handler类定义了如下的函数，其中gather和rewrite函数用于加密处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class DMLHandler : public SQLHandler &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual AbstractQueryExecutor *</span><br><span class="line">        transformLex(Analysis &amp;a, LEX *lex) const;</span><br><span class="line">private:</span><br><span class="line">    virtual void gather(Analysis &amp;a, LEX *lex) const = 0;</span><br><span class="line">    virtual AbstractQueryExecutor * rewrite(Analysis &amp;a, LEX *lex) const = 0;</span><br><span class="line">protected:</span><br><span class="line">    DMLHandler() &#123;;&#125;</span><br><span class="line">    virtual ~DMLHandler() &#123;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个dml系列的handler都实现了自己的gather和rewrite函数，在gather阶段，对于每个要改写的单元，保存一个rewrite plain，里面记录了这个基本单元可以用什么方式来进行加密。然后在rewrite阶段，使用这些rewrite plain，对解析以后的Lex结构中的基本单元做加密，从而完成加密功能。</p>
<h4 id="ddl-handler："><a href="#ddl-handler：" class="headerlink" title="ddl handler："></a><strong>ddl handler：</strong></h4><p>ddl 系列的handler类定义了如下的函数，用于加密处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">virtual AbstractQueryExecutor *</span><br><span class="line">        rewriteAndUpdate(LEX *lex) const = 0;</span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<p>ddl系列类型的典型处理流程包含了两部分，一是对SQL语句进行加密，二是以delta类来基于数据库的变化，这个delta在next阶段会写入到本地的embedded数据库中。例如CREATE TABLE语句，delta需要记录添加的表的名字， 表有多少列，每列分别采用什么样的加密算法。这些功能全都实现在rewriteAndUpdate函数中了。对于DML来说，由于不会对表结构产生影响，就不需要delta做记录。</p>
<h4 id="Alter-table-handler"><a href="#Alter-table-handler" class="headerlink" title="Alter table handler"></a><strong>Alter table handler</strong></h4><p>对于ALTER TABLE语句，由于其可能包含多个不同的子命令，所以创建了很多的不同的subhandler来进行处理，其调用subhandler的相关代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">virtual AbstractQueryExecutor *</span><br><span class="line">        rewriteAndUpdate(Analysis &amp;a, LEX *lex, const Preamble &amp;pre) const &#123;</span><br><span class="line">        //获取多个subhandler</span><br><span class="line">        const std::vector&lt;AlterSubHandler *&gt; &amp;handlers =</span><br><span class="line">            sub_dispatcher-&gt;dispatch(lex);</span><br><span class="line">        assert(handlers.size() &gt; 0);</span><br><span class="line">	// 使用多个subhandler对LEX进行加密处理</span><br><span class="line">        LEX *new_lex ;</span><br><span class="line">        for (auto it : handlers) &#123;</span><br><span class="line">            new_lex = it-&gt;transformLex(a, new_lex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对于一个ALTER TABLE语句，存在多个subhandler的情况。这个信息保存在解析出来LEX结构的alter_info成员里面，通过位操作的方式，获得多个subhandler，分别进行加密处理。 部分代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//flags的可能值如下</span><br><span class="line">lex-&gt;alter_info.flags;</span><br><span class="line"></span><br><span class="line">#define ALTER_ADD_COLUMN        (1L &lt;&lt; 0)</span><br><span class="line">#define ALTER_DROP_COLUMN       (1L &lt;&lt; 1)</span><br><span class="line">#define ALTER_CHANGE_COLUMN     (1L &lt;&lt; 2)</span><br><span class="line">#define ALTER_ADD_INDEX         (1L &lt;&lt; 3)</span><br><span class="line">#define ALTER_DROP_INDEX        (1L &lt;&lt; 4)</span><br><span class="line">#define ALTER_RENAME            (1L &lt;&lt; 5)</span><br><span class="line">#define ALTER_ORDER             (1L &lt;&lt; 6)</span><br><span class="line">#define ALTER_OPTIONS           (1L &lt;&lt; 7)</span><br><span class="line">#define ALTER_CHANGE_COLUMN_DEFAULT (1L &lt;&lt; 8)</span><br><span class="line">#define ALTER_KEYS_ONOFF        (1L &lt;&lt; 9)</span><br><span class="line">#define ALTER_CONVERT           (1L &lt;&lt; 10)</span><br><span class="line">#define ALTER_RECREATE          (1L &lt;&lt; 11)</span><br><span class="line">#define ALTER_ADD_PARTITION     (1L &lt;&lt; 12)</span><br><span class="line">#define ALTER_DROP_PARTITION    (1L &lt;&lt; 13)</span><br><span class="line">#define ALTER_COALESCE_PARTITION (1L &lt;&lt; 14)</span><br><span class="line">#define ALTER_REORGANIZE_PARTITION (1L &lt;&lt; 15)</span><br><span class="line">#define ALTER_PARTITION          (1L &lt;&lt; 16)</span><br><span class="line">#define ALTER_ADMIN_PARTITION    (1L &lt;&lt; 17)</span><br><span class="line">#define ALTER_TABLE_REORG        (1L &lt;&lt; 18)</span><br><span class="line">#define ALTER_REBUILD_PARTITION  (1L &lt;&lt; 19)</span><br><span class="line">#define ALTER_ALL_PARTITION      (1L &lt;&lt; 20)</span><br><span class="line">#define ALTER_REMOVE_PARTITIONING (1L &lt;&lt; 21)</span><br><span class="line">#define ALTER_FOREIGN_KEY        (1L &lt;&lt; 22)</span><br><span class="line">#define ALTER_TRUNCATE_PARTITION (1L &lt;&lt; 23)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="从handler到executor"><a href="#从handler到executor" class="headerlink" title="从handler到executor"></a>从handler到executor</h3><p>executor 类型包含了很多的功能，其类型层次结构如下图所示。</p>
<p><img src="https://yiwenshao.github.io/blogGraph/project/cryptdb/classAbstractQueryExecutor.png"></p>
<p>其中主要的函数是：<strong>nextImpl</strong>。该函数一般基于boost 的coroutine机制来实现，将一个完整的功能分成几个部分。该函数在mysqlproxy/ConnectWrapper.cc 中的next函数里被调用。举例来说，对于SELECT语句，在mysqlproxy/ConnectWrapper.cc的rewrite阶段，得到的是<strong>DMLQueryExecutor</strong>。在mysqlproxy/ConnectWrapper.cc的next函数中，调用这个<strong>DMLQueryExecutor</strong>的nextImpl函数。第一次进入该函数的时候，返回加密以后的SQL。这个SQL传递给lua脚本，然后转发给MySQL处理并且获得加密以后的结果。在第二次进入<strong>nextImpl</strong>函数的时候，会对返回的加密结果进行解密，并将解密的结果返回给lua脚本，转发给客户端。这样，executor的函数执行，就可以和<a href="https://yiwenshao.github.io/2018/02/26/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%901-lua%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%BA%93/">“CryptDB代码分析1-lua与加密库”</a>中的介绍联系起来了。</p>
<h3 id="一个非常简单的例子"><a href="#一个非常简单的例子" class="headerlink" title="一个非常简单的例子"></a>一个非常简单的例子</h3><p>介绍完了原理，现在给出一个非常简单的SQL语句加密的例子，将之前介绍的内容串联起来。我们考虑<strong>SHOW TABLES</strong>这个命令，该命令会获取当前db总的表名，由于表名是加密过的，所以mysql-proxy还是对表名进行解密才可以将结果返回给客户端。</p>
<p>首先，客户端发送<strong>SHOW TABLES</strong>命令的时候，被mysql-proxy接收到，并且调用mysqlproxy/ConnectWrapper.cc中的rewrite函数，其内部进入Rewriter::dispatchOnLex函数，首先调用parser进行解析，获得了LEX类型。然后进行判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (noRewrite(*lex)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; else if (dml_dispatcher-&gt;canDo(lex)) &#123;</span><br><span class="line">	 const SQLHandler &amp;handler = dml_dispatcher-&gt;dispatch(lex);</span><br><span class="line">	 AbstractQueryExecutor * executor = handler.transformLex(a, lex);</span><br><span class="line">&#125; else if (ddl_dispatcher-&gt;canDo(lex)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于是dml语句，所以进入了第二个分支，得到了一个DMLHandler，并且调用transformLex函数。在transformlext函数内部，包含了gather和rewrite两个函数，首先获得rewrite plain，然后根据rewrite plain多lex的内部成员进行改写，最后返回的executor，这里的executor类型是ShowTableExecutor。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ShowTablesHandlers : public DMLHandler &#123;</span><br><span class="line">    virtual void gather(Analysis &amp;a, LEX *const lex) const</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual AbstractQueryExecutor *rewrite(Analysis &amp;a, LEX *lex) const</span><br><span class="line">    &#123;</span><br><span class="line">        return new ShowTablesExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，rewrite阶段完成。在ShowTableExecutor中保存了加密以后的SQL语句。需要主要的是，由于show tables语句比较简单，没有加密，gather阶段没有获取任何的rewrite plain，rewrite阶段自然也就没有多lex的内部成员进行修改，所以加密以后的SQL语句依然是<strong>SHOW TABLES</strong>。</p>
<p>然后到了next阶段，需要执行ShowTableExecutor中的nextImpl函数了，其实现如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ShowTablesExecutor::</span><br><span class="line">nextImpl(const ResType &amp;res, const NextParams &amp;nparams)</span><br><span class="line">&#123;</span><br><span class="line">    reenter(this-&gt;corot) &#123;</span><br><span class="line">    	//返回加密以后的SQL语句，在这里是 SHOW TABLES</span><br><span class="line">        yield return CR_QUERY_AGAIN(nparams.original_query);</span><br><span class="line">        yield &#123;</span><br><span class="line">            const std::shared_ptr&lt;const SchemaInfo&gt; &amp;schema =</span><br><span class="line">                nparams.ps.getSchemaInfo();</span><br><span class="line">            const DatabaseMeta *const dm =</span><br><span class="line">                schema-&gt;getChild(IdentityMetaKey(nparams.default_db));</span><br><span class="line">            TEST_ErrPkt(dm, &quot;failed to find the database &#x27;&quot;</span><br><span class="line">                            + nparams.default_db + &quot;&#x27;&quot;);</span><br><span class="line">            std::vector&lt;std::vector&lt;Item *&gt; &gt; new_rows;</span><br><span class="line">            for (const auto &amp;it : res.rows) &#123;</span><br><span class="line">                assert(1 == it.size());</span><br><span class="line">                for (const auto &amp;table : dm-&gt;getChildren()) &#123;</span><br><span class="line">                    assert(table.second);</span><br><span class="line">                    if (table.second-&gt;getAnonTableName()</span><br><span class="line">                        == ItemToString(*it.front())) &#123;</span><br><span class="line"></span><br><span class="line">                        const IdentityMetaKey &amp;plain_table_name</span><br><span class="line">                            = dm-&gt;getKey(*table.second.get());</span><br><span class="line">                        new_rows.push_back(std::vector&lt;Item *&gt;</span><br><span class="line">                            &#123;make_item_string(plain_table_name.getValue())&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //返回加密以后的表名</span><br><span class="line">            return CR_RESULTS(ResType(res, new_rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一次调用的时候，返回了加密以后的命令，进入<a href="https://yiwenshao.github.io/2018/02/26/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%901-lua%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%BA%93/">之前介绍的mysqlproxy/ConnectWrapper.cc中的next函数中的QUERY_COME_AGAIN分支</a>，这个SQL语句传递给lua脚本，并转发给MySQL执行，然后返回加密的结果给mysql-proxy。之后会再次调用next函数，进入到ShowTablesExecutor::nextImpl函数，执行第二个return，返回解密以后的表名，并且进入RESULTS分支，这次就可以将解密以后的表名字返回给客户端，这样该SQL语句的执行就结束了。关于带rewrite plain的操作过程，涉及到更多复杂的处理，将在后续文章中给出。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>之前已经介绍过，在CryptDB的模型下，一个SQL语句通过mysqlproxy的lua脚本进行处理，其主要的处理函数是rewrite和next。rewrite被调用一次，用于SQL语句的加密，next则会被多次调用，和mysql-proxy交互，来完成数据解密等功能。本文首先介绍了rewrite阶段。 该阶段通过SQL解析获得LEX结构进行加密，然后将LEX结构恢复成字符串。由于不同类型的SQL有不同的加密方法，需要使用dispatcher类为其分配不同的handler。rewrite阶段结束以后，得到了executor类，其中就包含了加密以后的SQL以及其他相关的信息。executor类型的nextImpl函数在next阶段被调用，分阶段完成返回加密的SQL，数据解密等功能。</p>
<h3 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h3><p><a target="_blank" rel="noopener" href="https://github.com/yiwenshao/Practical-Cryptdb"> 正在开发新功能的CryptDB分支: https://github.com/yiwenshao/Practical-Cryptdb </a><br><a href="https://yiwenshao.github.io/2018/02/26/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%901-lua%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%BA%93/">https://yiwenshao.github.io/2018/02/26/CryptDB代码分析1-lua与加密库/</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Yiwen Shao
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://yiwenshao.github.io/2018/03/06/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902-handler%E4%B8%8Eexecutor/" title="CryptDB代码分析2-handler与executor">https://yiwenshao.github.io/2018/03/06/CryptDB代码分析2-handler与executor/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/CryptDB/" rel="tag"># CryptDB</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/02/26/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%901-lua%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%BA%93/" rel="prev" title="CryptDB代码分析1-lua与加密库">
                  <i class="fa fa-chevron-left"></i> CryptDB代码分析1-lua与加密库
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/03/11/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%903-%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/" rel="next" title="CryptDB代码分析3-元数据管理结构">
                  CryptDB代码分析3-元数据管理结构 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yiwen Shao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
