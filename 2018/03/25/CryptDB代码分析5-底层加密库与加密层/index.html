<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yiwenshao.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="CryptDB要进行数据加密，需要实现具体的加密算法，然后使用加密层类型来进行封装。如果用户想在其上实现新的功能，一方面需要实现加密算法，一方面要添加加密层以及其他相关辅助结构。本文介绍这两者之间的一些接口设计，方便大家基于现有代码做实验。">
<meta property="og:type" content="article">
<meta property="og:title" content="CryptDB代码分析5-底层加密库与加密层">
<meta property="og:url" content="https://yiwenshao.github.io/2018/03/25/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%905-%E5%BA%95%E5%B1%82%E5%8A%A0%E5%AF%86%E5%BA%93%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%B1%82/index.html">
<meta property="og:site_name" content="yiwenshao">
<meta property="og:description" content="CryptDB要进行数据加密，需要实现具体的加密算法，然后使用加密层类型来进行封装。如果用户想在其上实现新的功能，一方面需要实现加密算法，一方面要添加加密层以及其他相关辅助结构。本文介绍这两者之间的一些接口设计，方便大家基于现有代码做实验。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/yiwenshao/yiwenshao.github.io/graph/blogGraph/project/cryptdb/3/classEncLayer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yiwenshao/yiwenshao.github.io/graph/blogGraph/project/cryptdb/5/classLayerFactory.png">
<meta property="article:published_time" content="2018-03-25T07:30:28.000Z">
<meta property="article:modified_time" content="2018-03-25T07:30:28.000Z">
<meta property="article:author" content="Yiwen Shao">
<meta property="article:tag" content="CryptDB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/yiwenshao/yiwenshao.github.io/graph/blogGraph/project/cryptdb/3/classEncLayer.png">


<link rel="canonical" href="https://yiwenshao.github.io/2018/03/25/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%905-%E5%BA%95%E5%B1%82%E5%8A%A0%E5%AF%86%E5%BA%93%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%B1%82/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yiwenshao.github.io/2018/03/25/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%905-%E5%BA%95%E5%B1%82%E5%8A%A0%E5%AF%86%E5%BA%93%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%B1%82/","path":"2018/03/25/CryptDB代码分析5-底层加密库与加密层/","title":"CryptDB代码分析5-底层加密库与加密层"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CryptDB代码分析5-底层加密库与加密层 | yiwenshao</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">yiwenshao</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">几种算法接口介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.</span> <span class="nav-text">接口总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">加密层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.</span> <span class="nav-text">加密层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B"><span class="nav-number">2.2.</span> <span class="nav-text">加密层的实现举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E5%B1%82%E7%AE%A1%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">加密层管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">4.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yiwen Shao"
      src="https://raw.githubusercontent.com/yiwenshao/yiwenshao.github.io/graph/blogGraph//avatar/zoro.jpg">
  <p class="site-author-name" itemprop="name">Yiwen Shao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiwenshao.github.io/2018/03/25/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%905-%E5%BA%95%E5%B1%82%E5%8A%A0%E5%AF%86%E5%BA%93%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/yiwenshao/yiwenshao.github.io/graph/blogGraph//avatar/zoro.jpg">
      <meta itemprop="name" content="Yiwen Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yiwenshao">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CryptDB代码分析5-底层加密库与加密层
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-25 15:30:28" itemprop="dateCreated datePublished" datetime="2018-03-25T15:30:28+08:00">2018-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Cryptdb%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">Cryptdb的设计与实现</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>CryptDB要进行数据加密，需要实现具体的加密算法，然后使用加密层类型来进行封装。如果用户想在其上实现新的功能，一方面需要实现加密算法，一方面要添加加密层以及其他相关辅助结构。本文介绍这两者之间的一些接口设计，方便大家基于现有代码做实验。</p>
<span id="more"></span>

<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>CryptDB使用了AES，OPE，blowfish，Pailliar，Search算法，用到了openssl以及NTL库，相关代码全部位于<strong>crypto</strong>目录下。这里主要关注其对外的接口，忽略算法的实现步骤。要实现新的算法，需要使用类似的方法定义接口并做内部实现。</p>
<h4 id="几种算法接口介绍"><a href="#几种算法接口介绍" class="headerlink" title="几种算法接口介绍"></a>几种算法接口介绍</h4><p><strong>blowfish</strong></p>
<p>blowfish算法实现位于crypto/blowfish.hh中。相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class blowfish &#123;</span><br><span class="line"> public:</span><br><span class="line">    blowfish(const std::string &amp;key) &#123;</span><br><span class="line">        BF_set_key(&amp;k, key.size(), (const uint8_t*) key.data());</span><br><span class="line">    &#125;</span><br><span class="line">    uint64_t encrypt(uint64_t pt) const &#123;</span><br><span class="line">        uint64_t ct;</span><br><span class="line">        block_encrypt(&amp;pt, &amp;ct);</span><br><span class="line">        return ct;</span><br><span class="line">    &#125;</span><br><span class="line">    uint64_t decrypt(uint64_t ct) const &#123;</span><br><span class="line">        uint64_t pt;</span><br><span class="line">        block_decrypt(&amp;ct, &amp;pt);</span><br><span class="line">        return pt;</span><br><span class="line">    &#125;</span><br><span class="line">    static const size_t blocksize = 8;</span><br><span class="line"> private:</span><br><span class="line">    BF_KEY k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，要使用blowfish，首先要有密钥key来完成初始化类，然后分别使用encrypt和decrypt函数来实现加解密。算法处理的数据类型是<strong>uint64_t。</strong></p>
<p><strong>AES</strong></p>
<p>CryptDB使用了两种AES的模式，其加解密相关的函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string</span><br><span class="line">encrypt_AES_CBC(const string &amp;ptext, const AES_KEY * enckey, string salt, bool dopad);</span><br><span class="line">string</span><br><span class="line">decrypt_AES_CBC(const string &amp;ctext, const AES_KEY * deckey, string salt, bool dounpad);</span><br><span class="line">string</span><br><span class="line">encrypt_AES_CMC(const string &amp;ptext, const AES_KEY * enckey, bool dopad);</span><br><span class="line">string</span><br><span class="line">decrypt_AES_CMC(const string &amp;ctext, const AES_KEY * deckey, bool dopad);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，使用AES也是需要有密钥，通过encrypt和decrypt函数来完成加解密功能。处理的数据类型是<strong>string。</strong></p>
<p><strong>Pailliar</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Paillier_priv : public Paillier&#123;</span><br><span class="line">	NTL::ZZ decrypt(const NTL::ZZ &amp;ciphertext) const;</span><br><span class="line">	NTL::ZZ encrypt(const NTL::ZZ &amp;plaintext);</span><br><span class="line">	NTL::ZZ add(const NTL::ZZ &amp;c0, const NTL::ZZ &amp;c1) const;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">//使用举例</span><br><span class="line">Paillier_priv * sk;</span><br><span class="line">sk = new Paillier_priv();</span><br><span class="line">    ZZ pt0 = NTL::to_ZZ(1);</span><br><span class="line">    ZZ pt1 = NTL::to_ZZ(2);</span><br><span class="line"></span><br><span class="line">const ZZ enc0 = sk-&gt;encrypt(pt0);</span><br><span class="line">const ZZ dec0 = sk-&gt;decrypt(enc0);</span><br><span class="line">const ZZ enc1 = sk-&gt;encrypt(pt1);</span><br><span class="line">const ZZ dec1 = sk-&gt;decrypt(enc1);</span><br><span class="line">assert((pt0+pt1)==sk-&gt;decrypt(sk-&gt;add(enc0,enc1)));</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>上面给出了一个Pailliar使用的例子，可以看到，Pailliar算法提供了加解密以及密文相加得到密文的功能(同态加法)。处理过程使用了NTL库中的ZZ大整数类型。</p>
<p><strong>Search</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class search_priv : public search &#123;</span><br><span class="line"> public:</span><br><span class="line">    search_priv(const std::string &amp;key, size_t csize_arg = defsize)</span><br><span class="line">        : search(csize_arg), master_key(key) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt;</span><br><span class="line">        transform(const std::vector&lt;std::string&gt; &amp;words);</span><br><span class="line">    std::string</span><br><span class="line">        wordkey(const std::string &amp;word);</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">    std::string</span><br><span class="line">        transform(const std::string &amp;word);</span><br><span class="line">    std::string master_key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于search，首先需要对输入文字做划分，形成不同的关键字，对关键字进行加密，这是函数transform的作用。在进行match的时候，则是通过wordKey函数对关键字处理形成token，然后使用token调用match函数进行匹配，输出的结果是一个bool类型。</p>
<p><strong>OPE</strong></p>
<p>OPE算法对于字符串和整数，实现分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OPE &#123;</span><br><span class="line">    NTL::ZZ encrypt(const NTL::ZZ &amp;ptext);</span><br><span class="line">    NTL::ZZ decrypt(const NTL::ZZ &amp;ctext);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OPE ope(rawkey,8*plain_size,8*ciph_size);</span><br><span class="line">std::string ptext=&quot;helloworld&quot;;</span><br><span class="line">std::string ps = toUpperCase(ptext);</span><br><span class="line">if (ps.size() &lt; plain_size)</span><br><span class="line">    ps = ps + std::string(plain_size - ps.size(), 0);</span><br><span class="line">uint32_t pv = 0;</span><br><span class="line">for (uint i = 0; i &lt; plain_size; i++) &#123;</span><br><span class="line">    pv = pv * 256 + static_cast&lt;int&gt;(ps[i]);</span><br><span class="line">&#125;</span><br><span class="line">const ZZ enc = ope.encrypt(to_ZZ(pv));</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以看到，对于整数来说，提供了加解密函数。并且由于OPE的性质，密文有保序的性质。对于字符串，还是同样的类实现，只是加密的时候做了处理，使得字符串加密依然可以保序。</p>
<h4 id="接口总结"><a href="#接口总结" class="headerlink" title="接口总结"></a>接口总结</h4><p>可以看到，在crypto目录中的代码提供了底层的加密功能，大部分类都提供了加解密函数encrypt和decrypt，如果算法有特定功能如同态加，则需要添加额外的函数。这些底层库没有使用MySQL内部数据类型。  <strong>所以，如果要自己添加新的算法，首先需要在crypto目录添加底层加密代码，对外提供encrypt，decrypt以及密文计算函数。</strong> 这部分代码可以独立编译运行以及测试。</p>
<h3 id="加密层"><a href="#加密层" class="headerlink" title="加密层"></a>加密层</h3><p>首先，下面代码中用到的加密层以及洋葱都是枚举类型，其相关的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//位于util/onions.hh</span><br><span class="line">typedef enum onion &#123;</span><br><span class="line">    oDET,</span><br><span class="line">    oOPE,</span><br><span class="line">    oAGG,</span><br><span class="line">    oSWP,</span><br><span class="line">    oPLAIN,</span><br><span class="line">    oBESTEFFORT,</span><br><span class="line">    oASHE,</span><br><span class="line">    oINVALID,</span><br><span class="line">&#125; onion;</span><br><span class="line">enum class SECLEVEL &#123;</span><br><span class="line">    INVALID,</span><br><span class="line">    PLAINVAL,</span><br><span class="line">    OPEFOREIGN,</span><br><span class="line">    OPE,</span><br><span class="line">    DETJOIN,</span><br><span class="line">    DET,</span><br><span class="line">    SEARCH,</span><br><span class="line">    HOM,</span><br><span class="line">    ASHE,</span><br><span class="line">    RND,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了这些枚举类型表示洋葱和加密层，接下来就需要具体的加密层的实现，以及一些辅助类来完成加密层的管理。</p>
<h4 id="加密层实现"><a href="#加密层实现" class="headerlink" title="加密层实现"></a>加密层实现</h4><p>加密层相关的类主要实现了以下几个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class EncLayer : public LeafDBMeta &#123;</span><br><span class="line">    virtual Create_field *</span><br><span class="line">        newCreateField(const Create_field &amp;cf,</span><br><span class="line">                       const std::string &amp;anonname = &quot;&quot;) const = 0;</span><br><span class="line">    virtual Item *encrypt(const Item &amp;ptext, uint64_t IV) const = 0;</span><br><span class="line">    virtual Item *decrypt(const Item &amp;ctext, uint64_t IV) const = 0;</span><br><span class="line">    virtual Item *decryptUDF(Item * const col, Item * const ivcol = NULL)</span><br><span class="line">        const;</span><br><span class="line">    virtual std::string doSerialize() const = 0;</span><br><span class="line">    std::string serialize(const DBObject &amp;parent) const</span><br><span class="line">    &#123;</span><br><span class="line">        return serial_pack(this-&gt;level(), this-&gt;name(),</span><br><span class="line">                           this-&gt;doSerialize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其类的继承结构之前已经介绍过，如下图：</p>
<p><img src="https://raw.githubusercontent.com/yiwenshao/yiwenshao.github.io/graph/blogGraph/project/cryptdb/3/classEncLayer.png"></p>
<p>相关要点如下：</p>
<ul>
<li>serialize函数实现了加密层的序列化</li>
<li>反序列化功能在LayerFactory管理类中实现，后面会介绍</li>
<li>加解密函数encrypt和decrypt，是对上面介绍的crypto目录中的底层库的封装。由于这里处理的都是item类型，所以需要进行item类型和普通数据类型的互相转换</li>
<li>decryptUDF用于返回一个UDF函数，做洋葱层次调整</li>
<li>newCreateField用来处理加密带来的数据类型的变化。比如原来是整数类型，经过了Pailliar的加密，就变成了二进制字符串类型</li>
</ul>
<p>除了上面的通用函数，具体的加密层也会有自己特有的函数来实现密文计算功能。</p>
<h4 id="加密层的实现举例"><a href="#加密层的实现举例" class="headerlink" title="加密层的实现举例"></a>加密层的实现举例</h4><p>我们以pailliar(HOM)为例，给出一个加密层实现的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class HOM : public EncLayer &#123;</span><br><span class="line">public:</span><br><span class="line">    Create_field * newCreateField(const Create_field &amp;cf,</span><br><span class="line">                                  const std::string &amp;anonname = &quot;&quot;)</span><br><span class="line">        const;</span><br><span class="line">    Item *encrypt(const Item &amp;p, uint64_t IV) const;</span><br><span class="line">    Item * decrypt(const Item &amp;c, uint64_t IV) const;</span><br><span class="line">    </span><br><span class="line">    //expr is the expression (e.g. a field) over which to sum</span><br><span class="line">    Item *sumUDA(Item *const expr) const;</span><br><span class="line">    Item *sumUDF(Item *const i1, Item *const i2) const;</span><br><span class="line">protected:</span><br><span class="line">    std::string const seed_key;</span><br><span class="line">    static const uint nbits = 1024;</span><br><span class="line">    mutable Paillier_priv * sk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Create_field *</span><br><span class="line">HOM::newCreateField(const Create_field &amp;cf,</span><br><span class="line">                    const std::string &amp;anonname) const&#123;</span><br><span class="line">    return arrayCreateFieldHelper(cf, 2*nbits/BITS_PER_BYTE,</span><br><span class="line">                                  MYSQL_TYPE_VARCHAR, anonname,</span><br><span class="line">                                  &amp;my_charset_bin);</span><br><span class="line">&#125;</span><br><span class="line">Item *</span><br><span class="line">HOM::encrypt(const Item &amp;ptext, uint64_t IV) const&#123;</span><br><span class="line">    const ZZ enc = sk-&gt;encrypt(ItemIntToZZ(ptext));</span><br><span class="line">    return ZZToItemStr(enc);</span><br><span class="line">&#125;</span><br><span class="line">Item *</span><br><span class="line">HOM::decrypt(const Item &amp;ctext, uint64_t IV) const &#123;</span><br><span class="line">    const ZZ enc = ItemStrToZZ(ctext);</span><br><span class="line">    const ZZ dec = sk-&gt;decrypt(enc);</span><br><span class="line">    return ZZToItemInt(dec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的简化代码展示了以下三点</p>
<ul>
<li>加密层类型是对crypto目录中的加密相关类的封装，比如这里的HOM封装了Paillier_priv类型</li>
<li>encrypt与decrypt中，对item类型进行转换，使得其能够适配crypto目录中相关底层库进行加解密，之后又将结果转换为item类型返回</li>
<li>sumUDF和sumUDA返回UDF，来实现MySQL Server端的同态加法操作(参考之前的文章以及原始论文中的介绍)，其相关UDF的实现位于udf/edb.cc中，关于UDF可以参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/10a980667819">这里</a>，如果要自己写加密层，同样需要熟悉UDF的编写规则</li>
<li>newCreateField函数返回了新的Create_field类型，来表示经过HOM加密以后的数据类型</li>
</ul>
<p>对于最后一点，我们继续看arrayCreateFieldHelper函数内部的具体实现，其简化的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Create_field*</span><br><span class="line">lowLevelcreateFieldHelper(const Create_field *f0)&#123;</span><br><span class="line">    f0-&gt;length = field_length;</span><br><span class="line">    f0-&gt;sql_type = type;</span><br><span class="line">    return f0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Create_field中有lenghth和sql_type两个成员。一开始的时候，sql_type是MYSQL_TYPE_LONG，是表示整数类型。而这里的函数只要把sql_type变为MYSQL_TYPE_VARCHAR并设置对应的长度为256就行了。</p>
<p>再举一个实际的例子，我们执行这样的SQL语句：<strong>CREATE TABLE student(id integer)<strong>，并且对id这列只设置HOM一个洋葱，在MySQL端执行</strong>SHOW CREATE TABLE</strong>以后看到的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这里省略了额外的salt列</span><br><span class="line">CREATE TABLE `table_NRDDWIRZPY` (</span><br><span class="line">  `NSPUQRQGCEoADD` varbinary(256) DEFAULT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>可以看到，原来的integer变成了varbinary(256)，这个变化就是通过newCreateField函数的Create_field机制实现的。我们在处理阶段修改了解析以后的LEX结构中的Create_field成员，所以在将LEX结构转化回字符串类型的SQL语句时，就可以得到包含正确数据类型的SQL语句。</p>
<h4 id="加密层管理"><a href="#加密层管理" class="headerlink" title="加密层管理"></a>加密层管理</h4><p>加密层的创建依靠LayerFactory结构，不同的加密层有自己的factory。而这些factory又通过EncLayerFactory类来实现管理，其创建相关的代码以及类的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/yiwenshao/yiwenshao.github.io/graph/blogGraph/project/cryptdb/5/classLayerFactory.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class EncLayerFactory &#123;</span><br><span class="line">public:</span><br><span class="line">    static std::unique_ptr&lt;EncLayer&gt;</span><br><span class="line">        encLayer(onion o, SECLEVEL sl, const Create_field &amp;cf,</span><br><span class="line">                 const std::string &amp;key);</span><br><span class="line">    // creates EncLayer from its serialization </span><br><span class="line">    static std::unique_ptr&lt;EncLayer&gt;</span><br><span class="line">        deserializeLayer(unsigned int id, const std::string &amp;serial);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;EncLayer&gt;</span><br><span class="line">EncLayerFactory::encLayer(onion o, SECLEVEL sl, const Create_field &amp;cf,</span><br><span class="line">                          const std::string &amp;key)</span><br><span class="line">&#123;</span><br><span class="line">    switch (sl) &#123;</span><br><span class="line">        case SECLEVEL::RND: &#123;return RNDFactory::create(cf, key);&#125;</span><br><span class="line">        case SECLEVEL::DET: &#123;return DETFactory::create(cf, key);&#125;</span><br><span class="line">        case SECLEVEL::DETJOIN: &#123;return DETJOINFactory::create(cf, key);&#125;</span><br><span class="line">        case SECLEVEL::OPE:&#123;return OPEFactory::create(cf, key);&#125;</span><br><span class="line">        case SECLEVEL::OPEFOREIGN:&#123;return OPEFOREIGNFactory::create(cf,key);&#125;</span><br><span class="line">        case SECLEVEL::HOM: &#123;return HOMFactory::create(cf, key);&#125;</span><br><span class="line">        case SECLEVEL::ASHE: &#123;return std::unique_ptr&lt;EncLayer&gt;(new ASHE(cf,key));&#125;</span><br><span class="line">        case SECLEVEL::SEARCH: &#123;</span><br><span class="line">            return std::unique_ptr&lt;EncLayer&gt;(new Search(cf, key));</span><br><span class="line">        &#125;</span><br><span class="line">        case SECLEVEL::PLAINVAL: &#123;</span><br><span class="line">            return std::unique_ptr&lt;EncLayer&gt;(new PlainText());</span><br><span class="line">        &#125;</span><br><span class="line">        default:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FAIL_TextMessageError(&quot;unknown or unimplemented security level&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;EncLayer&gt;</span><br><span class="line">EncLayerFactory::deserializeLayer(unsigned int id,</span><br><span class="line">                                  const std::string &amp;serial)&#123;</span><br><span class="line">    assert(id);</span><br><span class="line">    const SerialLayer li = serial_unpack(serial);</span><br><span class="line">    switch (li.l) &#123;</span><br><span class="line">        case SECLEVEL::RND:</span><br><span class="line">            return RNDFactory::deserialize(id, li);</span><br><span class="line">        case SECLEVEL::DET:</span><br><span class="line">            return DETFactory::deserialize(id, li);</span><br><span class="line">        case SECLEVEL::DETJOIN:</span><br><span class="line">            return DETJOINFactory::deserialize(id, li);</span><br><span class="line">        case SECLEVEL::OPEFOREIGN:</span><br><span class="line">            return OPEFOREIGNFactory::deserialize(id,li);</span><br><span class="line">        case SECLEVEL::OPE:</span><br><span class="line">            return OPEFactory::deserialize(id, li);</span><br><span class="line">        case SECLEVEL::HOM:</span><br><span class="line">            return std::unique_ptr&lt;EncLayer&gt;(new HOM(id, serial));</span><br><span class="line">        case SECLEVEL::ASHE: return std::unique_ptr&lt;EncLayer&gt;(new ASHE(id, serial));</span><br><span class="line">        case SECLEVEL::SEARCH:</span><br><span class="line">            return std::unique_ptr&lt;EncLayer&gt;(new Search(id, serial));</span><br><span class="line">        case SECLEVEL::PLAINVAL:</span><br><span class="line">            return std::unique_ptr&lt;EncLayer&gt;(new PlainText(id));</span><br><span class="line">        default:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FAIL_TextMessageError(&quot;unknown or unimplemented security level&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可以看到LayerFactory系列的类，主要提供了create和deserialize函数，前者用于在内存中直接创建加密层，后者用于对磁盘读取的数据做反序列化来创建加密层，<a href="https://yiwenshao.github.io/2018/03/19/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%904-%E5%8A%A0%E5%AF%86%E5%85%83%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/">上一篇文章</a>介绍的元数据读取过程中的反序列化函数，就来自这里的LayerFactory。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本文我们可以发现，crypto目录实现了<strong>底层加密库</strong>，主要就是要对外提供encrypt，decrypt，以及密文计算函数。这个库操作的数据类型是普通的字符串和整数。这个模块和MySQL没有依赖，可以独立编译。</p>
<p>CryptDB需要对MySQL的parser中的LEX结构中的Item类型做加密，底层加密库不能直接处理Item，所以在EncLayer中要做一个封装，这部分的内容主要实现在<strong>main/CryptoHandlers.cc</strong>，用于处理数据类型的转化。此外，EncLayer还需要处理序列化，UDF返回等功能。为了辅助加密层类型的使用，设计了LayerFactory系列的类，用于构造加密层类，这个构造分为普通构造和反序列化构造。这些factory类又通过EncLayerFactory类型来进行统一管理。通过这些机制，底层的加密库就和CryptDB的实现连接起来了，CryptDB会调用封装好的EncLayer，而不直接使用底层的加密库。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a target="_blank" rel="noopener" href="https://github.com/yiwenshao/Practical-Cryptdb">https://github.com/yiwenshao/Practical-Cryptdb</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Yiwen Shao
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://yiwenshao.github.io/2018/03/25/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%905-%E5%BA%95%E5%B1%82%E5%8A%A0%E5%AF%86%E5%BA%93%E4%B8%8E%E5%8A%A0%E5%AF%86%E5%B1%82/" title="CryptDB代码分析5-底层加密库与加密层">https://yiwenshao.github.io/2018/03/25/CryptDB代码分析5-底层加密库与加密层/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/CryptDB/" rel="tag"># CryptDB</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/03/19/CryptDB%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%904-%E5%8A%A0%E5%AF%86%E5%85%83%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/" rel="prev" title="CryptDB代码分析4-加密元数据读写">
                  <i class="fa fa-chevron-left"></i> CryptDB代码分析4-加密元数据读写
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yiwen Shao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
